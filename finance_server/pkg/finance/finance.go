package finance

// import (
// 	"finance_server/internal/domain/entity"

// 	"sort"
// )

// // type SaleResult interface {
// // 	GetProduct() string
// // 	GetProfitMargin() float64
// // }

// // func (sr entity.SalesResult) GetProduct() string {
// // 	return sr.Product
// // }

// // func (sr entity.SalesResult) GetProfitMargin() float64 {
// // 	return sr.ProfitMargin
// // }

// type Finances struct{}

// // Step 1: Calculate total revenue generated each day
// // // This function takes a slice of sales data and returns daily revenue for each day.

// // Step 2: Calculate average revenue per product

// // Step 2: Calculate average revenue per product

// // Step 3: Identify top-selling products

// // Step 4: Calculate profit margin for each product
// func (f Finances) CalculateAllProfitMarginService(sales []entity.Sale) []entity.SalesResult {
// 	results := make([]entity.SalesResult, 0, len(sales))
// 	for _, sale := range sales {
// 		revenue := sale.Price * float64(sale.UnitsSold)
// 		cost := sale.Cost * float64(sale.UnitsSold)
// 		profitMargin := (revenue - cost) / revenue
// 		result := entity.SalesResult{
// 			Product:      sale.Product,
// 			ProfitMargin: profitMargin,
// 		}
// 		results = append(results, result)
// 	}
// 	return results
// }

// // Step 5: Calculate total cost of goods sold each day
// func (s *Finances) CalculateDailyCostService(salesData []entity.Sale) map[string]float64 {
// 	dailyCost := make(map[string]float64)
// 	for _, sale := range salesData {
// 		productCost := sale.Cost * float64(sale.UnitsSold)
// 		if val, ok := dailyCost[sale.Date]; ok {
// 			dailyCost[sale.Date] = val + productCost
// 		} else {
// 			dailyCost[sale.Date] = productCost
// 		}
// 	}
// 	return dailyCost
// }

// // Step 6: Calculate gross profit for each day

// // Step 7: Calculate gross profit margin
// func (s *Finances) CalculateGrossProfitMarginService(salesData []entity.Sale) map[string]float64 {
// 	dailyRevenue := s.CalculateDailyRevenueService(salesData)
// 	grossProfit := s.CalculateGrossProfit(salesData)
// 	grossProfitMargin := make(map[string]float64)
// 	for date, revenue := range dailyRevenue {
// 		grossProfitMargin[date] = grossProfit[date] / revenue
// 	}
// 	return grossProfitMargin
// }

// // Step 8: Analyze sales trends over time
// func (s *Finances) AnalyzeSalesTrendsService(salesData []entity.Sale) map[string]interface{} {
// 	dailyRevenue := s.CalculateDailyRevenueService(salesData)
// 	// Create a slice to store the revenue data
// 	revenueSlice := make([]float64, 0, len(dailyRevenue))
// 	for _, revenue := range dailyRevenue {
// 		revenueSlice = append(revenueSlice, revenue)
// 	}

// 	// Sort the revenue data in ascending order
// 	sort.Float64s(revenueSlice)

// 	// Calculate the median revenue
// 	medianRevenue := calculateMedian(revenueSlice)

// 	// Calculate the percentage change in revenue from day to day
// 	percentChange := make(map[string]float64)
// 	keys := make([]string, 0, len(dailyRevenue))
// 	for key := range dailyRevenue {
// 		keys = append(keys, key)
// 	}
// 	sort.Strings(keys)
// 	for i := 1; i < len(keys); i++ {
// 		currKey := keys[i]
// 		prevKey := keys[i-1]
// 		currRevenue := dailyRevenue[currKey]
// 		prevRevenue := dailyRevenue[prevKey]
// 		percentChange[currKey] = (currRevenue - prevRevenue) / prevRevenue * 100
// 	}

// 	// Store the results in a map and return
// 	results := make(map[string]interface{})
// 	results["medianRevenue"] = medianRevenue
// 	results["percentChange"] = percentChange
// 	return results
// }

// // Helper function to calculate the median of a slice of floats
// func calculateMedian(slice []float64) float64 {
// 	if len(slice) == 0 {
// 		return 0
// 	}
// 	sort.Float64s(slice)
// 	middle := len(slice) / 2
// 	median := slice[middle]
// 	if len(slice)%2 == 0 {
// 		median = (median + slice[middle-1]) / 2
// 	}
// 	return median
// }

// // Step 9: Calculate average daily revenue
// func (s *Finances) CalculateAverageDailyRevenueService(salesData []entity.Sale) float64 {
// 	dailyRevenue := s.CalculateDailyRevenueService(salesData)
// 	var sum float64
// 	for _, revenue := range dailyRevenue {
// 		sum += revenue
// 	}
// 	return sum / float64(len(dailyRevenue))
// }

// // Step 10: Determine total revenue generated by each store
// func (s *Finances) CalculateStoreRevenueService(salesData []entity.Sale) map[string]float64 {
// 	storeRevenue := make(map[string]float64)
// 	for _, sale := range salesData {
// 		if val, ok := storeRevenue[sale.Date]; ok {
// 			storeRevenue[sale.Date] = val + sale.Price*float64(sale.UnitsSold)
// 		} else {
// 			storeRevenue[sale.Date] = sale.Price * float64(sale.UnitsSold)
// 		}
// 	}
// 	return storeRevenue
// }

// // SECOND PART OF FINANCE FUNCTION ..........................................................
// func (f Finances) AnalyzeProfitabilityByRegionService(salesData []entity.Sale) map[string]float64 {
// 	regionRevenue := make(map[string]float64)
// 	regionCost := make(map[string]float64)
// 	for _, sale := range salesData {
// 		productRevenue := sale.Price * float64(sale.UnitsSold)
// 		if revenue, ok := regionRevenue[sale.Region]; ok {
// 			regionRevenue[sale.Region] = revenue + productRevenue
// 		} else {
// 			regionRevenue[sale.Region] = productRevenue
// 		}
// 		if cost, ok := regionCost[sale.Region]; ok {
// 			regionCost[sale.Region] = cost + (sale.Cost * float64(sale.UnitsSold))
// 		} else {
// 			regionCost[sale.Region] = sale.Cost * float64(sale.UnitsSold)
// 		}
// 	}
// 	regionProfit := make(map[string]float64)
// 	for region, revenue := range regionRevenue {
// 		cost := regionCost[region]
// 		regionProfit[region] = revenue - cost
// 	}
// 	return regionProfit
// }

// // IdentifyUnderperformingProducts calculates the revenue and units sold for each product, and returns a list of underperforming products.
// func (f Finances) IdentifyUnderperformingProductsService(salesData []entity.Sale) []string {
// 	productRevenue := make(map[string]float64)
// 	productUnitsSold := make(map[string]int)

// 	// Calculate total revenue and units sold for each product
// 	for _, sale := range salesData {
// 		productRevenue[sale.Product] += sale.Price * float64(sale.UnitsSold)
// 		productUnitsSold[sale.Product] += sale.UnitsSold
// 	}

// 	// Identify underperforming products (those with below-average revenue)
// 	underperformingProducts := []string{}
// 	for product, revenue := range productRevenue {
// 		averageRevenue := 0.0
// 		if productUnitsSold[product] > 0 {
// 			averageRevenue = revenue / float64(productUnitsSold[product])
// 		}
// 		if revenue < averageRevenue {
// 			underperformingProducts = append(underperformingProducts, product)
// 		}
// 	}
// 	return underperformingProducts
// }

// func (f Finances) AnalyzePricingStrategyService(salesData []entity.Sale) map[string]float64 {
// 	productPrice := make(map[string]float64)
// 	for _, sale := range salesData {
// 		if price, ok := productPrice[sale.Product]; ok {
// 			if sale.Price < price {
// 				productPrice[sale.Product] = sale.Price
// 			}
// 		} else {
// 			productPrice[sale.Product] = sale.Price
// 		}
// 	}
// 	return productPrice
// }

// func (f Finances) ForecastFutureSales(salesData []entity.Sale) (map[string]float64, error) {
// 	// Calculate daily revenue
// 	return make(map[string]float64), nil
// }
