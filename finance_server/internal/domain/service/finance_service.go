package service

import (
	"finance_server/internal/domain/entity"
	"sort"
)

type FinanceService struct {
}

func (f FinanceService) CalculateDailyRevenueService(salesData <-chan []entity.Sale) map[string]float64 {
	dailyRevenue := make(map[string]float64)
	request := <-salesData
	for _, sale := range request {
		productRevenue := sale.Price * float64(sale.UnitsSold)
		if revenue, ok := dailyRevenue[sale.Date]; ok {
			dailyRevenue[sale.Date] = revenue + productRevenue
		} else {
			dailyRevenue[sale.Date] = productRevenue
		}
	}
	return dailyRevenue
}

func (f FinanceService) CalculateAverageRevenueService(salesData <-chan []entity.Sale) float64 {
	totalRevenue, totalUnitsSold := 0.0, 0
	request := <-salesData
	for _, sale := range request {
		totalRevenue += sale.Price * float64(sale.UnitsSold)
		totalUnitsSold += sale.UnitsSold
	}
	if totalUnitsSold == 0 {
		return 0.0
	}
	return totalRevenue / float64(totalUnitsSold)
}

func (f FinanceService) CalculateAverageRevenuePerProductService(salesData []entity.Sale) map[string]float64 {
	productRevenue, productUnitsSold := make(map[string]float64), make(map[string]int)
	for _, sale := range salesData {
		// Check if the product's revenue and units sold have already been calculated.
		if revenue, ok := productRevenue[sale.Product]; ok {
			// If the revenue and units sold have already been calculated, add the revenue and units sold generated by the current sale to the existing revenue and units sold.
			productRevenue[sale.Product] = revenue + sale.Price*float64(sale.UnitsSold)
			productUnitsSold[sale.Product] = productUnitsSold[sale.Product] + sale.UnitsSold
		} else {
			// If the revenue and units sold haven't been calculated yet, set the revenue and units sold for the product to the revenue and units sold generated by the current sale.
			productRevenue[sale.Product] = sale.Price * float64(sale.UnitsSold)
			productUnitsSold[sale.Product] = sale.UnitsSold
		}
	}

	// Calculate the average revenue for each product.
	averageRevenuePerProduct := make(map[string]float64)
	for product, revenue := range productRevenue {
		unitsSold := productUnitsSold[product]
		averageRevenuePerProduct[product] = revenue / float64(unitsSold)
	}

	return averageRevenuePerProduct
}

func (f FinanceService) IdentifyTopSellingProductsService(salesData []entity.Sale) []entity.Sale {
	sortedSalesData := make([]entity.Sale, len(salesData))
	copy(sortedSalesData, salesData)
	sort.Slice(sortedSalesData, func(i, j int) bool {
		return sortedSalesData[i].UnitsSold > sortedSalesData[j].UnitsSold
	})
	return sortedSalesData
}

func (f FinanceService) CalculateAllProfitMarginService(sales []entity.Sale) []entity.SalesResult {
	results := make([]entity.SalesResult, 0, len(sales))
	for _, sale := range sales {
		revenue := sale.Price * float64(sale.UnitsSold)
		cost := sale.Cost * float64(sale.UnitsSold)
		profitMargin := (revenue - cost) / revenue
		result := entity.SalesResult{
			Product:      sale.Product,
			ProfitMargin: profitMargin,
		}
		results = append(results, result)
	}
	return results
}

func (f FinanceService) CalculateDailyCostService(salesData []entity.Sale) map[string]float64 {
	dailyCost := make(map[string]float64)
	for _, sale := range salesData {
		productCost := sale.Cost * float64(sale.UnitsSold)
		if val, ok := dailyCost[sale.Date]; ok {
			dailyCost[sale.Date] = val + productCost
		} else {
			dailyCost[sale.Date] = productCost
		}
	}
	return dailyCost
}

func (f FinanceService) CalculateGrossProfitService(salesData <-chan []entity.Sale) map[string]float64 {
	d := <-salesData
	dailyRevenue := f.CalculateDailyRevenueService(salesData)
	dailyCost := f.CalculateDailyCostService(d)

	grossProfit := make(map[string]float64)
	for date, revenue := range dailyRevenue {
		grossProfit[date] = revenue - dailyCost[date]
	}
	return grossProfit
}

func (f FinanceService) CalculateGrossProfitMarginService(salesData <-chan []entity.Sale) map[string]float64 {
	dailyRevenue := f.CalculateDailyRevenueService(salesData)
	grossProfit := f.CalculateGrossProfitService(salesData)
	grossProfitMargin := make(map[string]float64)
	for date, revenue := range dailyRevenue {
		grossProfitMargin[date] = grossProfit[date] / revenue
	}
	return grossProfitMargin
}

func (f FinanceService) AnalyzeSalesTrendsService(salesData <-chan []entity.Sale) map[string]interface{} {
	dailyRevenue := f.CalculateDailyRevenueService(salesData)
	// Create a slice to store the revenue data
	revenueSlice := make([]float64, 0, len(dailyRevenue))
	for _, revenue := range dailyRevenue {
		revenueSlice = append(revenueSlice, revenue)
	}

	// Sort the revenue data in ascending order
	sort.Float64s(revenueSlice)

	// Calculate the median revenue
	medianRevenue := calculateMedian(revenueSlice)

	// Calculate the percentage change in revenue from day to day
	percentChange := make(map[string]float64)
	keys := make([]string, 0, len(dailyRevenue))
	for key := range dailyRevenue {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	for i := 1; i < len(keys); i++ {
		currKey := keys[i]
		prevKey := keys[i-1]
		currRevenue := dailyRevenue[currKey]
		prevRevenue := dailyRevenue[prevKey]
		percentChange[currKey] = (currRevenue - prevRevenue) / prevRevenue * 100
	}

	// Store the results in a map and return
	results := make(map[string]interface{})
	results["medianRevenue"] = medianRevenue
	results["percentChange"] = percentChange
	return results
}

func (f FinanceService) CalculateAverageDailyRevenueService(salesData <-chan []entity.Sale) float64 {
	dailyRevenue := f.CalculateDailyRevenueService(salesData)
	var sum float64
	for _, revenue := range dailyRevenue {
		sum += revenue
	}
	return sum / float64(len(dailyRevenue))
}

func (f FinanceService) CalculateStoreRevenueService(salesData []entity.Sale) map[string]float64 {
	storeRevenue := make(map[string]float64)
	for _, sale := range salesData {
		if val, ok := storeRevenue[sale.Date]; ok {
			storeRevenue[sale.Date] = val + sale.Price*float64(sale.UnitsSold)
		} else {
			storeRevenue[sale.Date] = sale.Price * float64(sale.UnitsSold)
		}
	}
	return storeRevenue
}

func (f FinanceService) AnalyzeProfitabilityByRegionService(salesData []entity.Sale) map[string]float64 {
	regionRevenue := make(map[string]float64)
	regionCost := make(map[string]float64)
	for _, sale := range salesData {
		productRevenue := sale.Price * float64(sale.UnitsSold)
		if revenue, ok := regionRevenue[sale.Region]; ok {
			regionRevenue[sale.Region] = revenue + productRevenue
		} else {
			regionRevenue[sale.Region] = productRevenue
		}
		if cost, ok := regionCost[sale.Region]; ok {
			regionCost[sale.Region] = cost + (sale.Cost * float64(sale.UnitsSold))
		} else {
			regionCost[sale.Region] = sale.Cost * float64(sale.UnitsSold)
		}
	}
	regionProfit := make(map[string]float64)
	for region, revenue := range regionRevenue {
		cost := regionCost[region]
		regionProfit[region] = revenue - cost
	}
	return regionProfit
}

func (f FinanceService) IdentifyUnderperformingProductsService(salesData []entity.Sale) []string {
	productRevenue := make(map[string]float64)
	productUnitsSold := make(map[string]int)

	// Calculate total revenue and units sold for each product
	for _, sale := range salesData {
		productRevenue[sale.Product] += sale.Price * float64(sale.UnitsSold)
		productUnitsSold[sale.Product] += sale.UnitsSold
	}

	// Identify underperforming products (those with below-average revenue)
	underperformingProducts := []string{}
	for product, revenue := range productRevenue {
		averageRevenue := 0.0
		if productUnitsSold[product] > 0 {
			averageRevenue = revenue / float64(productUnitsSold[product])
		}
		if revenue < averageRevenue {
			underperformingProducts = append(underperformingProducts, product)
		}
	}
	return underperformingProducts
}

func (f FinanceService) AnalyzePricingStrategyService(salesData []entity.Sale) map[string]float64 {
	productPrice := make(map[string]float64)
	for _, sale := range salesData {
		if price, ok := productPrice[sale.Product]; ok {
			if sale.Price < price {
				productPrice[sale.Product] = sale.Price
			}
		} else {
			productPrice[sale.Product] = sale.Price
		}
	}
	return productPrice
}

func (f FinanceService) ForecastFutureSales(salesData []entity.Sale) (map[string]float64, error) {
	// Calculate daily revenue
	return make(map[string]float64), nil
}

// Helper function to calculate the median of a slice of floats
func calculateMedian(slice []float64) float64 {
	if len(slice) == 0 {
		return 0
	}
	sort.Float64s(slice)
	middle := len(slice) / 2
	median := slice[middle]
	if len(slice)%2 == 0 {
		median = (median + slice[middle-1]) / 2
	}
	return median
}
